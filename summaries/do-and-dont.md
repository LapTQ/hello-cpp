

## Print newline

* ‚úÖ Use character `"\n"`:
* ‚ùå Avoid using `std::endl`. It flushes the buffer, which is slower.

## Comma operator

* ‚ùå Avoid using **comma operator**, except in `for` loops:
```C++
std::cout << (++x, ++y) << '\n'; // evaluates left and right, then retuns the right operand
```


## Macro

* ‚úÖ Can use `#if 0` to comment out a large block of code that contains **multi-line comments**. Change it to `#if 1` when needed.
* ‚ùå Avoid using **object-like macros with substitution text**, as better methods are available.


## `#include` and header files

* ‚ùå Avoid `#including` .cpp files.
* Including header files from other directories:
    * ‚ùå Avoid using relative path (e.g, `#include "headers/myHeader.h"`).
    * ‚úÖ Instead, tell your compiler about other locations to search for (e.g., `-I./lessons/11-header-files/others`).
* ‚úÖ To maximize the chance that missing includes will be flagged by compiler, order your `#includes` as follows:
    1. the paired header file (`add.cpp` and `#include "add.h"`)
    2. other headers from same project
    3. 3rd party lib headers
    4. standard lib headers
* ‚úÖ Always have a **header guard** in a header file to avoid violating ODR from having **a** code file #include a header (which may contain **definition**) multiple time. 
    * ‚ö†Ô∏è However, header guards do not prevent **multiple** code file `#include` the same header.
* ‚ùå Don't use `#pragme once`. Use header guard instead.
* ‚úÖ Use a complex name for your header guard (e.g., `PROJECT_PATH_FILE_H`). This is to avoid case where 2 separated header files (e.g., `A/config.h` and `B/config.h`) might have the same name of header guard (e.g., `CONFIG_H`).


## Debugging

* ‚úÖ use `std::cerr` (not buffered) instead of `std::cout` (may be buffered).
* To enable/disable debugging mode:
    * üëç Solution 1: Conditionalizing your debugging code with macro: `#define ENABLE_DEBUG` in a header file and `#include` it everywhere. But ensure that you're not misspell `ENABLE_DEBUG` or forgot `#include` the header file.
    * üëç Use `plog` logger. ‚ùå Don't use `std::clog` logger.


## Data types

* ‚ùå Avoid using unsigned types.
* ‚ùå Avoid `short`, `long`, fast/least integral types (prefer a fixed-width integer type instead).
* ‚ùå Avoid 8-bit fixed-width integer types (prefer a 16-bit fixed-width integer type instead).
* ‚ùå Avoid `long double`.
* ‚ö†Ô∏è `std::int8_t` and `std::uint8_t` likely behave like `signed char` and `unsigned char` instead of integers.


### Input text

* To read whitespace characters (type `char`):
    * ‚ùå can't use `std::cin >>`
    * ‚úÖ use `std::cin.get(ch)`
* To read a line (including whitespace):
    * ‚ùå don't use `std::cin >>`
    * ‚úÖ use `std::getline()`


## Compile-time optimization

* ‚úÖ Most compilers default to no optimization, so if you‚Äôre using a command-line 
  compiler, you‚Äôll need to enable optimization yourself.


## Using `std:string` and `std::string_view`

* ‚úÖ To view a substring of a string, use `std::string_view` with `.remove_prefix()` and `.remove_suffix()`.
* Initialize a `std::string_view`:
    * ‚ùå Don't initialize with a `std::string` **literal**. Because, the temporary `std::string` literal will be destroyed at the end of the statement:

        ```C++
        std::string_view name { "Alex"s }; // "Alex"s creates a temporary std::string
        std::cout << name << '\n'; // undefined behavior
        ```
    * üëç It's okay to initialize with a C-style string **literal** or a `std::string_view` **literal**. Because, C-style string literals exist for the entire program.
* ‚ö†Ô∏è Returning a string in a function that has return type `std::string_view`: 2 main cases when this can be done safely:
    * üëç when the returned object is a C-style string literals:

        ```C++
        std::string_view getBoolName(bool b)
        {
            return "false";
        }
        ```
    * üëç when the returned object is a function parameter of type `std::string_view`:

        ```C++
        std::string_view firstAlphabetical(std::string_view s1, std::string_view s2)
        {
            if (s1 < s2)
                return s1;
            return s2;
        }
        ```


## Comparing floating point values

* ‚ùå It's very dangerous to compare floating point values directly using relational operators (<, >, <=, >=, ==, !=).
    
    üëç One exception: compare a floating point **literal** with a **variable of the same type** that has been initialized with a **literal of the same type**.
* ‚ùå It's generally not safe to compare floating point values of **different** types.


## `goto` statement

* ‚ùå Avoid using `goto` statement.
* ‚úÖ Exception: when you need to exit a nested loop.


## Pseudo-random number generation

* üëç For most applications, Mersenne Twister is fine. However, by modern PRNG standards, Mersenne Twister is a bit outdated.
* ‚úÖ For highest/fastest quality random results, consider:
    * The Xoshiro family and Wyrand for non-cryptographic PRNGs.
    * The Chacha family for cryptographic (non-predictable) PRNGs.


## Constant expressions

* ‚úÖ Constexpr/consteval functions should be defined in a header file.
* ‚úÖ If you want to force a constexpr function to be evaluated at compile time, use `consteval` with a helper function:
    ```C++
    consteval auto compileTimeEval(auto value) { return value; }

    constexpr int greater2(int x, int y) { return (x > y ? x : y); }

    int main()
    {
        compileTimeEval(greater2(3, 4)); // will be evaluated at compile time
    }
    ```
* ‚ùå C++ does not currently provide any reliable mechanisms to notify you if a function is being evaluated at compile time or runtime.


## Namespaces

* ‚úÖ Naming convention: Company or org :: project or library :: module (e.g. `Foosoft::Foologger::Lang`)
* ‚úÖ Prefer defineing global variables inside a namespace rather than in the global namespace.
* ‚ùå Do not use using-statements in header files.
* ‚ùå Do not use using-statements before an #include directive.
* ‚úÖ If you want to version your code, you can use **inline namespaces**.


## Linkage

* ‚úÖ If you want to make all declarations to have internal linkage without having to use `static` keyword, you can put them in an unnamed namespace.
    

## Share variables across multiple files

* Global **constants**:
    * üëç Solution 1: Global constants as internal variables
        1. Create a header file and define a namespace in it.
        2. Put the global constants inside the namespace, make it `constexpr`.
        3. `#include` the header file wherever you need.

        üëç Simple
        
        üëéÔ∏è Changing in the header file will require recompiling all files that include it.
        
        üëéÔ∏è Each translation unit get its own copy of the constants => use more memory.
    * üëç Solution 2: Global constants as external variables
        1. Create a .cpp file and define a namespace in it.
        2. Put the global constants inside the namespace, make it `extern constexpr`.
        3. Create a header file and forward declare the global constants.
        4. `#include` the header file wherever you need.

        üëç Changing the constant only require recompiling the .cpp file.
        
        üëéÔ∏è Because forward declarations can‚Äôt be constexpr, the constant cannot be used in constant expression outside of the .cpp file which defines the constant.
    * ‚úÖ Solution3: Global constants as inline variables:
        1. Create a header file and define a namespace in it.
        2. Put the global constants inside the namespace, make it `inline constexpr`.
        3. `#include` the header file wherever you need.

        üëç The constants will only be instantiated once and shared across all code files (linker will de-duplicate definition).
        
        üëç Can be used in constant expressions in any translation unit.
        
        üëéÔ∏è Changing in the headeer file will require recompiling all files that include it.


## Assertion

* ‚úÖ Favor `static_assert` over `assert()` whenever possible.


## Explicit type conversion

* ‚úÖ Use `static_cast` for most type conversions.
* ‚ùå Do not use C-style casts: e.g., `(int) x`.
* ‚ùå Do not use const cast and reinterpret cast unless you have a very good reason.


## Type deduction

* ‚úÖ Can use **trailing return type syntax** to make code more readable and dynamic. E.g., this function has return type based on its parameter types: `auto add(int x, double y) -> std::common_type_t<decltype(x), decltype(y)>;`
* ‚úÖ Use `auto*` instead of `auto` for type deduction with pointers. It's more clear and *less error-prone*.

    ```C++
    int* x;

    // auto => order not matter
    const auto y { x }; // int* const (a const pointer)
    auto const y { x }; // int* const (a const pointer)

    // auto* => order matters
    const auto* y { x }; // const int* (a pointer to const)
    auto* const y { x }; // int* const (a const pointer)
    ```


## Function templates

* ‚úÖ Use non-type template parameters to when we need to pass constexpr values to functions/class types. For example, to `static_assert` at compile time.
* Function templates in multiple files:
    * ‚ùå A forward declaration of the function template is not enough:
    
        ```C++
        // add.h
        template <typename T>
        T add(T x, T y);
        
        // add.cpp => assume that the function template is defined here
        // ...

        // main.cpp
        #include "add.h"
        int main()
        {
            add(1, 2);
            return 0;
        }
        ```

        Linker error: 
        * When compiling `main.cpp`, it assumes that `addOne<int>` exists elsewhere and will be linked in later.
        * When compile `add.cpp`, there is no uses of this template so the compiler will not instantiate anything.
    * ‚úÖ Put all the template code in a header (.h) file instead of a source (.cpp) file. It does not violate the ODR (because functions implicitly instantiated from templates are implicitly inline).


## Pointers

* ‚úÖ Use `nullptr` for null pointers. ‚ùå  Don't use `NULL` or `0`.


## Passing arguments to functions

* ‚úÖ It's okay to pass fundamental types by value. They are cheap to copy. Don't pass by reference unless you need to modify the argument.
* ‚úÖ It's okay pass class types by reference (or const reference). Binding a reference is always cheap.
* ‚ö†Ô∏è Don't pass a `std::string` to a function by value. Because, it will make an expensive copy.
* ‚úÖ It's okay to pass a `std::string_view` by value for read-only access purpose. It's cheap. For function parameters, prefer `std::string_view` over `const std::string&` in most cases (whatever the passed argument is `std::string`, `std::string_view`, or C-style string).
* ‚ö†Ô∏è When passing by reference, ensure the type of the argument matches the type of the parameter. Otherwise, it will results in an unexpected (and possibly expensive) type conversion.
* ‚úÖ It's okay to pass by address. Copying a pointer is always cheap.



## Returning values from functions

* ‚úÖ When your function may or may not return a value of type `T`:
    * Use `std::optional<T>` if `T` would normally be passed by value.

    This is because `std::optional` has value semantics: local objects are copied.


## Program-defined types: Enumerated types

* ‚úÖ It's okay to pass enumerations by value. They are small and cheap to copy.
* ‚úÖ Favor scoped enumerations over unscoped enumerations.
* For **unscoped enumerations**, 
    * ‚úÖ Put the unscoped enumerated type inside a namespace to avoid name collisions.
    * ‚úÖ It's recommended to add an "invalid" or "unknown" enumerator with value 0 to avoid semantically invalid enumeration when it's zero-initialized:

        ```C++
        enum Animal
        {
            unknown = 0, // default value (0)
            cat,
            dog,
        };
        ```
    * ‚ùå Not safe:

        ```C++
        enum Color { red, };
        enum Fruit { banana, };
        Color color { red };
        Fruit fruit { banana };
        std::cout << std::boolalpha << (color == fruit) << '\n'; // true, compare as integers
        ```


## Program-defined types: Class types

* ‚úÖ When adding a new member variable to a struct, put it at the end to avoid breaking existing code. Because, struct initializes its members in the order they are declared.
* ‚úÖ Always provide default values for your members (inside the class type definition).
* Getter:
    * ‚úÖ Make getter `const`, so they can be called on both const and non-const objects.
    * ‚úÖ Getters should return *by value* or by *const lvalue reference*.
* ‚ùå Don't use `( )` for initialization
* ‚úÖ You can do method chaining by returning `this`: `calc.add(5).sub(3).mult(4);`
* ‚úÖ You can reset a class back to default state by using `this` and default constructor:

    ```C++
    void reset()
    {
        *this = {}; // value-initialize a new object and overwrite the implicit object
    }
    ```


## Program-defined types and header files

* ‚úÖ A program-defined type used in multiple code files should be defined in a header file with the same name as the program-defined type and then `#included` into each code file as needed.
* ‚úÖ For non-template classes:
    * put your class definitions in a header file with the same name as the class, and
    * define non-trivial member functions outside of the class and in a .cpp file with the same name as the class, and
    * define trivial member functions (such as access functions, constructors with empty bodies, etc‚Ä¶) inside the class definition.

    For example:

    `Day.h`:
    ```C++
    #ifndef DAY_H
    #define DAY_H

    class Day
    {
    private:
        int m_day{};

    public:
        Day(int day);
        void print() const;
    };

    #endif
    ```

    `Day.cpp`:
    ```C++
    #include "Day.h"

    Day::Day(int day) // constructor definition
        : m_day{ day }
    {
        // ...
    }

    void Day::print() const // print function definition
    {
        std::cout << "Day(" << m_day << ")\n";
    };
    ```
    
    Note that that .cpp file also needs to be compiled into any project that uses the header file so that the linker can connect calls to the member functions to their definitions.
* For template classes:
    * ‚ùå Simply putting the class definition in a header file, and the member function definitions in a similarly named .cpp file will not work.
    * ‚úÖ Solution 1: Put the entire template class in a header file.

        üëéÔ∏è Increase your compile and link times.
    * ‚úÖ Solution 2: Move the contents of .cpp to a new file named .inl, and include the .inl file at the end of the header file (inside the header guard).

        üëéÔ∏è Same result as solution 1.

        üëç Keep things a little more organized.
    * ‚úÖ Solution 3: Use an explicit instantiation file. For example: `Array.h`, `Array.cpp`, and `templates.cpp`:

        `templates.cpp`:
        ```C++
        // Ensure the full Array template definition can be seen
        #include "Array.h"
        #include "Array.cpp" // we're breaking best practices here, but only in this one place

        // #include other .h and .cpp template definitions you need here

        template class Array<int>; // Explicitly instantiate template Array<int>
        template class Array<double>; // Explicitly instantiate template Array<double>
        ```

        The `template class` command causes the compiler to explicitly instantiate the template class.

        üëç More efficient.
        
        üëéÔ∏è Requires more files.




    
        




Just like function templates, class templates are typically defined in header files.










Is there any reason to use = default copy constructor? Yes, for two reasons:
1. It's generally better to be explicit than implicit.
2. Implicit behavior can change (e.g. if you add a move constructor or move assignment, the implicit copy constructor will no longer be generated, but an = default copy constructor still will be generated).







Inline functions are typically defined in "header" files, where they can be #included into the top of any code file 
   that needs to see the full definition of the identifier. This ensures that all inline definitions for an identifier are "identical".
   This is particularly useful for "header-only libraries" (no .cpp files are included).

Why not make all functions inline and defined in a header file?
- Mainly because doing so can increase your compile times significantly.
- Conversely, if you change the code in a .cpp file, only that .cpp file needs to be recompiled.
- If you change any of the code in the header, then you‚Äôll need to recompile every file that includes that header.