/* Poor seed quality (or "underseeding") 

- If we want different randomized numbers each time, then we need some way to vary the seed.
- we’ll typically use a seed generation algorithm that is designed to produce seed values.
- If a PRNG is not provided with enough bits of quality seed data, we say that it is underseeded. 
*/

/*
- The length of the sequence before a PRNG begins to repeat itself is known as the "period".
*/

/* Randomization in C++

- For most applications, Mersenne Twister is fine.
- However, by modern PRNG standards, Mersenne Twister is a bit outdated.

- The biggest issue with Mersenne Twister is that its results can be predicted after seeing 624 generated numbers.
- If you are developing an application that requires the highest quality random results 
  (e.g. a statistical simulation), the fastest results, or one where non-predictability is important 
  (e.g. cryptography), you’ll need to use a 3rd party library:
  ++ The Xoshiro family and Wyrand for non-cryptographic PRNGs.
  ++ The Chacha family for cryptographic (non-predictable) PRNGs.
*/

/* Mersenne Twister

- The random library has support for two Mersenne Twister types:
  ++ std::mt19937: a 32-bit Mersenne Twister
  ++ std::mt19937_64: a 64-bit Mersenne Twister
*/

/* Only seed a PRNG once

- do not reseed it (unless you have a specific reason to do so).
- Because it can cause the results to be less random, or not random at all.
*/

#include <iostream>
#include <random>
#include <chrono>

int main()
{
    // generate a random number 
	std::mt19937 mt{}; // Instantiate a 32-bit Mersenne Twister
	std::cout << mt() << '\n'; // identical value each run

    // uniform distribution
    std::uniform_int_distribution uid{ 1, 6 }; // Create a uniform distribution from 1 to 6
    for (int count{ 1 }; count <= 6; ++count)
    {
        std::cout << uid(mt) << '\n'; // Generate a random number from 1 to 6
    }

    // different seed each time using the current time
    std::mt19937 mt2{ 
        static_cast<std::mt19937::result_type>(
		    std::chrono::steady_clock::now().time_since_epoch().count()
		) 
    };
    std::cout << mt2() << '\n';

    // different seed each time using the random device
    std::mt19937 mt3{ std::random_device{}() };
    std::cout << mt3() << '\n';

    // seed_seq, better seed quality
    std::random_device rd{};
	  std::seed_seq ss{ rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd() }; // get 8 integers of random numbers
    std::mt19937 mt4{ ss };
    std::cout << mt4() << '\n';

	return 0;
}

/* Mersenne Twiste and underseeding issues 

(Deepseek R1)
- Its state consists of 624 32-bit integers (occupying 19937 bits, hence the name). To work properly, 
  it needs all 624 values to be initialized with "random" data.
- This large state is what allows it to generate a vast sequence of pseudorandom numbers with a 
  period of 2^19937 − 1.
- It is designed to use all 624 values in its state to produce statistically good randomness.
  => Mersenne Twister’s quality depends on the entropy (randomness) of its initial state.
- If you initialize only a single value (e.g., with std::random_device{}()), the algorithm must 
  algorithmically expand that single seed into the entire 624-value state.
- This expansion is deterministic and linear => The resulting state lacks true entropy beyond the initial seed.
- ideally we want our seed data to be as many bits as the state of our PRNG, or our PRNG will be underseeded.
  (std::seed_seq is a type that was designed to help with this)

- For example, seeding std::mt19937 with a single 32-bit value will never generate the number 42 as its first output.
*/

/* std::seed_seq

- If you initialize std::seed_seq with a single value (e.g. from std::random_device) 
  and then initialize a Mersenne Twister with the std::seed_seq object, 
  std::seed_seq will generate 623 values of additional seed data. 
- If we initialize std::seed_seq with 8 values from std::random_device instead of 1, 
  then the remaining values generated by std::seed_seq should be much better.
*/

/* Why not give std::seed_seq 624 values from std::random_device?

- You can, but this is likely to be slow.
*/

/* Warming up a PRNG

- When a PRNG is underseeded, the initial values it generates may not be as random as we’d like.
- Some PRNGs benefit from being “warmed up”: discarding the first few values.
- The longer the period of a PRNG, the more values you should discard.

- The seed_seq initialization used by std::mt19937 performs a warm up, 
  so we don’t need to explicitly warm up std::mt19937 objects.
*/


/* References

- https://www.learncpp.com/cpp-tutorial/introduction-to-random-number-generation/
- https://www.learncpp.com/cpp-tutorial/generating-random-numbers-using-mersenne-twister/
*/